/*
    --- Huomioitavaa ---
    SensorTag-laitteessa on RAM-muistia 20kB = 20 * 1024.
    Omille taskeille aina prioriteetti 2 ja ne tulee aina keskeytt‰‰ sleep-kutsulla.
    Tiedonsiirtotaskin prioriteettiin 1 ei ole syyt‰ koskea, eik‰ funktio tarvitse sleep-kutsua.
*/

#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Task.h>
#include <ti/drivers/PIN.h>
#include <ti/drivers/pin/PINCC26XX.h>
#include <ti/drivers/I2C.h>
#define STACKSIZE 2048

Char helloWorldStack[STACKSIZE];
Char temperatureSensorStack[STACKSIZE];
static PIN_Handle buttonHandle;
static PIN_State buttonState;
static PIN_Handle ledHandle;
static PIN_State ledState;

PIN_Config buttonConfig[] = {
   Board_BUTTON0  | PIN_INPUT_EN | PIN_PULLUP | PIN_IRQ_NEGEDGE, 
   PIN_TERMINATE // M‰‰ritys lopetetaan aina t‰h‰n vakioon
};

PIN_Config ledConfig[] = {
   Board_LED0 | PIN_GPIO_OUTPUT_EN | PIN_GPIO_LOW | PIN_PUSHPULL | PIN_DRVSTR_MAX, 
   PIN_TERMINATE // M‰‰ritys lopetetaan aina t‰h‰n vakioon
};


Void helloWorldTaskFxn(UArg arg0, UArg arg1) {
   System_printf("Mun argumentit ovat %ld ja %ld.. heippa!\n", arg0, arg1);
   System_flush();
}

Void startHelloWorldTask() {
   Task_Params params;
   Task_Handle handle;
   Task_Params_init(&params);
   params.stackSize = STACKSIZE;
   params.stack = &helloWorldStack; 
   params.priority = 2;
   params.arg0 = 127; 
   params.arg1 = 0xFFFF; 	
   handle = Task_create((Task_FuncPtr)helloWorldTaskFxn, &params, NULL);
   if (handle == NULL) System_abort("Task create failed");
}

Void temperatureSensorTaskFxn(UArg arg0, UArg arg1) {
   unsigned int    i;
   float        temperature;
   // 2. i2c-v‰yl‰n alustus
   // RTOS:n i2c-muuttujat
   I2C_Handle      i2c;
   I2C_Params      i2cParams;
   I2C_Transaction i2cTransaction;
   // Alustetaan i2c
   I2C_Params_init(&i2cParams);
   i2cParams.bitRate = I2C_400kHz;
   i2c = I2C_open(Board_I2C_TMP, &i2cParams);
   if (i2c == NULL) {
      System_abort("Error Initializing I2C\n");
   }
   // 3. Kommunikointi i2c-v‰yl‰n kautta
   // i2c-viesteille l‰hetys- ja vastaanottopuskurit
   // Taulukkojen koko riippu siit‰ kuinka monta tavua ollaan l‰hett‰m‰ss‰/vastottamassa!
   // N‰m‰ arvot on annettu jokaisen rekisterin kohdalta datakirjassa 
   uint8_t         txBuffer[1]; // Nyt l‰hetet‰‰n yksi tavu
   uint8_t         rxBuffer[2]; // Nyt vastaanotetaan kaksi tavua
   // Luodaan i2c-viesti tietorakenteeseen
   // Vakio: sensorin DATAREKISTERIN osoite TMP007_REG_TEMP
   // Saadaan datakirjasta, ts. t‰‰lt‰ kurssimateriaalista   
   // Vakio: laitteen i2c-osoite Board_TMP007_ADDR saadaan Board.h-tiedostosta
   txBuffer[0] = TMP007_REG_TEMP; // Laiterekisteri, mihin operaatio kohdistuu
   i2cTransaction.slaveAddress = Board_TMP007_ADDR; // No nyt laitteen osoite 
   i2cTransaction.writeBuf = txBuffer; // L‰hetyspuskuri
   i2cTransaction.writeCount = 1; // L‰hetet‰‰n yksi tavu
   i2cTransaction.readBuf = rxBuffer; // Vastaanottopuskuri
   i2cTransaction.readCount = 2; // Vastaanotetaan kaksi tavua
   for (i = 0; i < 10; i++) {
      // L‰hetet‰‰n yll‰m‰‰ritelty i2c-viesti
      if (I2C_transfer(i2c, &i2cTransaction)) {
         // Ok, saatiin vastaus
         // Muunna luettu data rxBufferista l‰mpˆtilaksi (datakirjassa kerrotun mukaisesti)
         // temperature = ...;
         // System_printf("L‰mpˆtila on %.2f C\n", temperature);
	 System.printf("L‰mpˆtila luettiin... (ks. rxBuffer)\n");         
	 System_flush();
      } else {
         System_printf("I2C Bus fault\n");
      }
      // Taskimme on kohtelias
      Task_sleep(1000000 / Clock_tickPeriod);
   }
   // 4. i2c-yhteyden sulkeminen
   I2C_close(i2c);	
}

Void startTemperatureSensorTask() {
   Task_Params params;
   Task_Handle handle;
   Task_Params_init(&params);
   params.stackSize = STACKSIZE;
   params.stack = &temperatureSensorStack; 
   params.priority = 2;
   params.arg0 = 127; 
   params.arg1 = 0xFFFF; 	
   handle = Task_create((Task_FuncPtr)temperatureSensorTaskFxn, &params, NULL);
   if (handle == NULL) System_abort("Task create failed");
}

Void blinkListenerFxn(PIN_Handle handle, PIN_Id pinId) {
   // Vaihdetaan led-pinnin tilaa negaatiolla
   PIN_setOutputValue( ledHandle, Board_LED0, !PIN_getOutputValue( Board_LED0 ) );
}

Void startBlinkListener() {
   buttonHandle = PIN_open(&buttonState, buttonConfig);
   if (!buttonHandle) System_abort("Error initializing button pins\n");
   ledHandle = PIN_open(&ledState, ledConfig);
   if (!ledHandle) System_abort("Error initializing LED pins\n");
   if (PIN_registerIntCb(buttonHandle, &buttonFxn) != 0) System_abort("Error registering button callback function");
}

int main(void) {
   // Laitteen alustus
   Board_initGeneral();
   Board_initI2C();
   runHelloWorldTask();
   startBlinkListener();
   // Terveisi‰..
   System_printf("Hello world!\n");
   System_flush();
   // Ohjelma k‰ynnistyy
   BIOS_start();
   return (0);
}